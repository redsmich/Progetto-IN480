/*
#version 450
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer GridBuffer {
    uint data[]; 
} grid;

layout(push_constant) uniform PushConsts {
    int width;
    int height;
    int currentRow; //la riga che stiamo calcolando ORA
} pc;

//shared memory: 256 thread + 1 bordo sx + 1 bordo dx = 258
shared uint s_row[gl_WorkGroupSize.x + 2];

// Helper per estrarre il bit (0 o 1) dal colore RGBA
// Assumiamo: Nero (1) -> Alpha pieno, Bianco (0) -> Alpha pieno
uint getBit(uint packedColor) {
    // Se il canale rosso Ã¨ 0, consideriamolo "attivo" (1), altrimenti inattivo (0)
    // Nota: Nel tuo codice C++ packRGBA mette c=0 se bit=1.
    uint r = (packedColor >> 0) & 0xFF; 
    return (r == 0) ? 1 : 0;
}

uint packColor(uint bit) {
    uint c = (bit == 1) ? 0 : 255; 
    return (0xFF << 24) | (c << 16) | (c << 8) | c; 
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationID.x;
    uint wgSize = gl_WorkGroupSize.x;
    
    if (gid >= pc.width) return;

    // Calcoliamo gli offset nel buffer unico
    // prevRow: riga da cui LEGGERE
    // curRow: riga dove SCRIVERE
    uint prevRowOffset = (pc.currentRow - 1) * pc.width;
    uint curRowOffset  = pc.currentRow * pc.width;

    // --- FASE 1: CARICAMENTO IN SHARED MEMORY ---
    // Ogni thread carica il proprio pixel dalla riga precedente
    uint centerPixel = grid.data[prevRowOffset + gid];
    s_row[lid + 1] = getBit(centerPixel);

    // Gestione dei bordi (Halo) per la shared memory
    // Il thread 0 del gruppo carica anche il pixel a SINISTRA del gruppo
    if (lid == 0) {
        // Gestione wrap-around (mondo toroidale)
        uint leftIdx = (gid == 0) ? (pc.width - 1) : (gid - 1);
        s_row[0] = getBit(grid.data[prevRowOffset + leftIdx]);
    }

    // L'ultimo thread del gruppo carica anche il pixel a DESTRA del gruppo
    if (lid == wgSize - 1 || gid == pc.width - 1) {
        uint rightIdx = (gid + 1) % pc.width;
        s_row[lid + 2] = getBit(grid.data[prevRowOffset + rightIdx]);
    }

    // Aspettiamo che tutti abbiano caricato la shared memory
    barrier();

    // --- FASE 2: APPLICAZIONE REGOLA 30 ---
    // Ora leggiamo solo dalla shared memory (molto veloce)
    uint L = s_row[lid];     // Indice locale + 0
    uint C = s_row[lid + 1]; // Indice locale + 1 (me stesso)
    uint R = s_row[lid + 2]; // Indice locale + 2

    // Regola 30: Left XOR (Center OR Right)
    uint newBit = L ^ (C | R);

    // Scrittura in memoria globale
    grid.data[curRowOffset + gid] = packColor(newBit);
}
*/





#version 450
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer GridBuffer {
    uint data[]; 
} grid;

layout(push_constant) uniform PushConsts {
    int width;
    int height;
    int currentRow; 
} pc;

shared uint s_row[gl_WorkGroupSize.x + 2];

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationID.x;
    uint wgSize = gl_WorkGroupSize.x;
    
    if (gid >= pc.width) return;

    uint prevRowOffset = (pc.currentRow - 1) * pc.width;
    uint curRowOffset  = pc.currentRow * pc.width;
    
    s_row[lid + 1] = grid.data[prevRowOffset + gid];

    if (lid == 0) {
        uint leftIdx = (gid == 0) ? (pc.width - 1) : (gid - 1);
        s_row[0] = grid.data[prevRowOffset + leftIdx];
    }

    if (lid == wgSize - 1 || gid == pc.width - 1) {
        uint rightIdx = (gid + 1) % pc.width;
        s_row[lid + 2] = grid.data[prevRowOffset + rightIdx];
    }

    barrier(); // Aspettiamo tutti i thread del gruppo

    uint L = s_row[lid];     
    uint C = s_row[lid + 1]; 
    uint R = s_row[lid + 2]; 

    uint newBit = L ^ (C | R);

    grid.data[curRowOffset + gid] = newBit;
}